// Copyright Â© 2022-2023 GothicKit Contributors.
// SPDX-License-Identifier: MIT
#include "ModelScriptGenerator.hh"
#include "Internal.hh"

#include "zenkit/Date.hh"
#include "zenkit/Stream.hh"

#include <sstream>

namespace zenkit {
	// ===== MdsGenerator Implementation =====
	MdsGenerator::MdsGenerator(Write* w, const std::string& model_name) : _m_writer(w), _m_model_name(model_name) {}

	void MdsGenerator::generate_script(const ModelScript& script) {
		// Write Model block
		_m_writer->write_string("// Generated by ZenKit ModelScript DSL Generator\n");
		_m_writer->write_string("Model (\"");
		if (_m_model_name.empty()) {
			std::string model_name = script.skeleton.name;
			std::transform(model_name.begin(), model_name.end(), model_name.begin(), ::toupper);
			size_t pos = model_name.find(".ASC");
			if (pos != std::string::npos) {
				model_name.erase(model_name.begin() + pos, model_name.end());
			}
			_m_writer->write_string(model_name);
		} else {
			_m_writer->write_string(_m_model_name);
		}
		_m_writer->write_string("\")\n{\n");

		// Write skeleton first (always present)
		write_skeleton(script.skeleton);

		// Iterate through lines to preserve source order
		for (const auto& line : script.lines) {
			switch (line.type) {
			case MdsElementType::SKELETON:
				// Already written at the top
				break;
			case MdsElementType::ANIMATION:
				write_animation(script.animations[line.index]);
				break;
			case MdsElementType::ANIMATION_ALIAS:
				write_animation_alias(script.aliases[line.index]);
				break;
			case MdsElementType::ANIMATION_BLEND:
				write_animation_blend(script.blends[line.index]);
				break;
			case MdsElementType::ANIMATION_COMBINE:
				write_animation_combine(script.combinations[line.index]);
				break;
			case MdsElementType::ANIMATION_DISABLED:
				write_disabled_animation(script.disabled_animations[line.index]);
				break;
			case MdsElementType::MODEL_TAG:
				write_model_tag(script.model_tags[line.index]);
				break;
			case MdsElementType::MESH:
				write_mesh(script.meshes[line.index]);
				break;
			case MdsElementType::ANI_ENUM:
				_m_writer->write_string("\taniEnum\n");
				_m_writer->write_string("\t{\n");
				break;
			case MdsElementType::ANI_ENUM_END:
				_m_writer->write_string("\t}\n");
				break;
			}
		}

		// Close Model block
		_m_writer->write_string("}\n");
	}

	void MdsGenerator::write_skeleton(const MdsSkeleton& skeleton) {
		std::ostringstream ss;
		ss << "\tmeshAndTree (\"" << skeleton.name;
		std::string skeleton_name = skeleton.name;

		std::transform(skeleton_name.begin(), skeleton_name.end(), skeleton_name.begin(), ::toupper);
		size_t pos = skeleton_name.find(".ASC");
		if (pos == std::string::npos) {
			ss << ".ASC\"";
		} else {
			ss << "\"";
		}

		if (skeleton.disable_mesh) {
			ss << " DONT_USE_MESH";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_mesh(const std::string& mesh) {
		_m_writer->write_string("\tregisterMesh (\"" + mesh + "\")\n");
	}

	void MdsGenerator::write_animation(const MdsAnimation& ani) {
		std::ostringstream ss;
		ss << "\t\tani (\"" << ani.name << "\" "
		   << ani.layer << " \""
		   << ani.next << "\" "
		   << ani.blend_in << " "
		   << ani.blend_out << " "
		   << format_flags(ani.flags) << " \""
		   << ani.model << "\" "
		   << format_direction(ani.direction) << " "
		   << ani.first_frame << " "
		   << ani.last_frame;

		if (ani.fps != 25.0f) {
			ss << " FPS:" << ani.fps;
		}
		if (ani.speed != 0.0f) {
			ss << " SPD:" << ani.speed;
		}
		if (ani.collision_volume_scale != 1.0f) {
			ss << " CVS:" << ani.collision_volume_scale;
		}

		ss << ")\n";
		_m_writer->write_string(ss.str());

		// Check if animation has any events
		if (ani.event_lines.empty()) {
			return;
		}

		// Write animation events
		_m_writer->write_string("\t\t{\n");

		for (const auto& line : ani.event_lines) {
			switch (line.type) {
			case MdsAniEventType::EVENT_TAG:
				write_event_tag(ani.events[line.index]);
				break;
			case MdsAniEventType::SOUND_EFFECT:
				write_event_sfx(ani.sfx[line.index]);
				break;
			case MdsAniEventType::SOUND_EFFECT_GROUND:
				write_event_sfx_ground(ani.sfx_ground[line.index]);
				break;
			case MdsAniEventType::PARTICLE_EFFECT:
				write_event_pfx(ani.pfx[line.index]);
				break;
			case MdsAniEventType::PARTICLE_EFFECT_STOP:
				write_event_pfx_stop(ani.pfx_stop[line.index]);
				break;
			case MdsAniEventType::MORPH_ANIMATION:
				write_event_morph(ani.morph[line.index]);
				break;
			case MdsAniEventType::CAMERA_TREMOR:
				write_event_tremor(ani.tremors[line.index]);
				break;
			}
		}

		_m_writer->write_string("\t\t}\n");
	}

	void MdsGenerator::write_animation_alias(const MdsAnimationAlias& alias) {
		std::ostringstream ss;
		ss << "\t\taniAlias (\"" << alias.name << "\" "
		   << alias.layer << " \""
		   << alias.next << "\" "
		   << alias.blend_in << " "
		   << alias.blend_out << " "
		   << format_flags(alias.flags) << " \""
		   << alias.alias << "\" "
		   << format_direction(alias.direction)
		   << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_animation_blend(const MdsAnimationBlend& blend) {
		std::ostringstream ss;
		ss << "\t\taniBlend (\"" << blend.name << "\" \""
		   << blend.next << "\"";
		if (blend.blend_in != 0.0f || blend.blend_out != 0.0f) {
			ss << " " << blend.blend_in << " " << blend.blend_out;
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_animation_combine(const MdsAnimationCombine& comb) {
		std::ostringstream ss;
		ss << "\t\taniComb (\"" << comb.name << "\" "
		   << comb.layer << " \""
		   << comb.next << "\" "
		   << comb.blend_in << " "
		   << comb.blend_out << " "
		   << format_flags(comb.flags) << " \""
		   << comb.model << "\" "
		   << comb.last_frame
		   << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_disabled_animation(const std::string& ani) {
		_m_writer->write_string("\t\taniDisable (\"" + ani + "\")\n");
	}

	void MdsGenerator::write_model_tag(const MdsModelTag& tag) {
		_m_writer->write_string("\t\tmodelTag (\"DEF_HIT_LIMB\" \"" + tag.bone + "\")\n");
	}

	void MdsGenerator::write_event_tag(const MdsEventTag& event) {
		std::ostringstream ss;
		ss << "\t\t\t*eventTag (" << event.frame << " \"";

		//TODO: check these values
		// Convert event type to string
		switch (event.type) {
		case MdsEventType::ITEM_CREATE:
			ss << "DEF_CREATE_ITEM\" \"" << event.slot << "\" \"" << event.item << "\"";
			break;
		case MdsEventType::ITEM_INSERT:
			ss << "DEF_INSERT_ITEM\" \"" << event.slot << "\"";
			break;
		case MdsEventType::ITEM_REMOVE:
			ss << "DEF_REMOVE_ITEM\"";
			break;
		case MdsEventType::ITEM_DESTROY:
			ss << "DEF_DESTROY_ITEM\"";
			break;
		case MdsEventType::ITEM_PLACE:
			ss << "DEF_PLACE_ITEM\"";
			break;
		case MdsEventType::ITEM_EXCHANGE:
			ss << "DEF_EXCHANGE_ITEM\" \"" << event.slot << "\" \"" << event.item << "\"";
			break;
		case MdsEventType::SET_FIGHT_MODE:
			ss << "DEF_FIGHTMODE\" \"";
			switch (event.fight_mode) {
			case MdsFightMode::FIST:
				ss << "FIST";
				break;
			case MdsFightMode::SINGLE_HANDED:
				ss << "1H";
				break;
			case MdsFightMode::DUAL_HANDED:
				ss << "2H";
				break;
			case MdsFightMode::BOW:
				ss << "BOW";
				break;
			case MdsFightMode::CROSSBOW:
				ss << "CBOW";
				break;
			case MdsFightMode::MAGIC:
				ss << "MAG";
				break;
			default:
				ss << "NONE";
				break;
			}
			ss << "\"";
			break;
		case MdsEventType::MUNITION_PLACE:
			ss << "DEF_PLACE_MUNITION\" \"" << event.slot << "\"";
			break;
		case MdsEventType::MUNITION_REMOVE:
			ss << "DEF_REMOVE_MUNITION\"";
			break;
		case MdsEventType::SOUND_DRAW:
			ss << "DEF_DRAWSOUND\"";
			break;
		case MdsEventType::SOUND_UNDRAW:
			ss << "DEF_UNDRAWSOUND\"";
			break;
		case MdsEventType::MESH_SWAP:
			ss << "DEF_SWAPMESH\" \"" << event.slot << "\" \"" << event.slot2 << "\"";
			break;
		case MdsEventType::TORCH_DRAW:
			ss << "DEF_DRAWTORCH\"";
			break;
		case MdsEventType::TORCH_INVENTORY:
			ss << "DEF_INV_TORCH\"";
			break;
		case MdsEventType::TORCH_DROP:
			ss << "DEF_DROP_TORCH\"";
			break;
		case MdsEventType::HIT_LIMB:
			ss << "DEF_HIT_LIMB\""; // TODO: up to 4 slots can be specified
			break;
		case MdsEventType::HIT_DIRECTION:
			ss << "DEF_HIT_DIR\"";  // TODO: argument direction
			break;
		case MdsEventType::DAMAGE_MULTIPLIER:
			ss << "DEF_DAM_MULTIPLIER\" \""; // TODO: DEF_DAM_MULTIPLY/DEF_DAM_MULTIPLIER? from gothic gmc. Possibly both are accepted, uses one float arg in quotation marks "0.2"
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::PARRY_FRAME:
			ss << "DEF_PAR_FRAME\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::OPTIMAL_FRAME:
			ss << "DEF_OPT_FRAME\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::HIT_END:
			ss << "DEF_HIT_END\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::COMBO_WINDOW:
			ss << "DEF_WINDOW\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		default:
			ss << "UNKNOWN\"";
			break;
		}

		if (event.attached) {
			ss << " ATTACH";
		}

		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_sfx(const MdsSoundEffect& sfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventSFX (" << sfx.frame << " \"" << sfx.name << "\"";
		if (sfx.range != 1000.0f) {
			ss << " R:" << sfx.range;
		}
		if (sfx.empty_slot) {
			ss << " EMPTY_SLOT";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_sfx_ground(const MdsSoundEffectGround& sfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventSFXGrnd (" << sfx.frame << " \"" << sfx.name << "\")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_pfx(const MdsParticleEffect& pfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventPFX (" << pfx.frame;
		if (pfx.index != 0) {
			ss << " " << pfx.index;
		}
		ss << " \"" << pfx.name << "\" \"" << pfx.position << "\"";
		if (pfx.attached) {
			ss << " ATTACH";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_pfx_stop(const MdsParticleEffectStop& pfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventPFXStop (" << pfx.frame << " " << pfx.index << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_morph(const MdsMorphAnimation& morph) {
		std::ostringstream ss;
		ss << "\t\t\t*eventMMStartAni (" << morph.frame << " \"" << morph.animation << "\"";
		if (!morph.node.empty()) {
			ss << " \"" << morph.node << "\"";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_tremor(const MdsCameraTremor& tremor) {
		std::ostringstream ss;
		ss << "\t\t\t*eventCamTremor (" << tremor.frame << " "
		   << tremor.field1 << " "
		   << tremor.field2 << " "
		   << tremor.field3 << " "
		   << tremor.field4 << ")\n";
		_m_writer->write_string(ss.str());
	}

	std::string MdsGenerator::format_flags(AnimationFlags flags) {
		std::string result;
		if (flags & AnimationFlags::MOVE) result += "M";
		if (flags & AnimationFlags::ROTATE) result += "R";
		if (flags & AnimationFlags::QUEUE) result += "E";
		if (flags & AnimationFlags::FLY) result += "F";
		if (flags & AnimationFlags::IDLE) result += "I";
		if (flags & AnimationFlags::INPLACE) result += "P";
		result += ".";
		return result;
	}

	std::string MdsGenerator::format_direction(AnimationDirection dir) {
		return dir == AnimationDirection::FORWARD ? "F" : "R";
	}

	// ===== MdsBinaryGenerator Implementation =====
	MdsBinaryGenerator::MdsBinaryGenerator(Write* w, const std::string& model_name) : _m_writer(w), _m_model_name(model_name) {}

	void MdsBinaryGenerator::generate_script(const ModelScript& script) {
		// Write root block
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ROOT, [&](Write* wr) {
			wr->write_uint(1);     // bool
			wr->write_string("\\_WORK\\DATA\\ANIMS\\"); // path
			wr->write_byte(static_cast<char>(0x0A));
		});

		// Write skeleton first (always present)
		write_skeleton(script.skeleton);

		// Iterate through lines to preserve source order
		for (const auto& line : script.lines) {
			switch (line.type) {
			case MdsElementType::SKELETON:
				// Already written at the top
				break;
			case MdsElementType::ANIMATION:
				write_animation(script.animations[line.index]);
				break;
			case MdsElementType::ANIMATION_ALIAS:
				write_animation_alias(script.aliases[line.index]);
				break;
			case MdsElementType::ANIMATION_BLEND:
				write_animation_blend(script.blends[line.index]);
				break;
			case MdsElementType::ANIMATION_COMBINE:
				write_animation_combine(script.combinations[line.index]);
				break;
			case MdsElementType::ANIMATION_DISABLED:
				write_disabled_animation(script.disabled_animations[line.index]);
				break;
			case MdsElementType::MODEL_TAG:
				write_model_tag(script.model_tags[line.index]);
				break;
			case MdsElementType::MESH:
				write_mesh(script.meshes[line.index]);
				break;
			case MdsElementType::ANI_ENUM:
				proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::animation_enum, [&](Write* wr) {});
				break;
			case MdsElementType::ANI_ENUM_END:
				proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::animation_enum_end, [&](Write* wr) {});
				break;
			}
		}

		// Close Model block
		//_m_writer->write_string("}\n");
	}

	void MdsBinaryGenerator::write_skeleton(const MdsSkeleton& skeleton) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::SOURCE, [&](Write* wr) {
			Date d {}; //TODO: get current time
			d.save(_m_writer); //date
			std::string model_name("\\_WORK\\DATA\\ANIMS\\");

			if (_m_model_name.empty()) {
				model_name.append(skeleton.name);
				std::transform(model_name.begin(), model_name.end(), model_name.begin(), ::toupper);
				size_t pos = model_name.find(".ASC");
				if (pos != std::string::npos) {
					model_name.erase(model_name.begin() + pos, model_name.end());
				}
			} else {
				model_name.append(_m_model_name);
			}

			model_name.append(".MDS");
			wr->write_string(model_name); // path
			wr->write_byte(static_cast<char>(0x0A));
		});
	}

	void MdsBinaryGenerator::write_mesh(const std::string& mesh) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::REGISTER_MESH, [&](Write* wr) {
			_m_writer->write_line(mesh);
		});
	}

	void MdsBinaryGenerator::write_animation(const MdsAnimation& ani) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ANIMATION, [&](Write* wr) {
			_m_writer->write_line(ani.name);
			_m_writer->write_uint(ani.layer);
			_m_writer->write_line(ani.next);
			_m_writer->write_float(ani.blend_in);
			_m_writer->write_float(ani.blend_out);
			_m_writer->write_line(format_flags(ani.flags));
			_m_writer->write_line(ani.model);
			_m_writer->write_line(ani.direction == AnimationDirection::BACKWARD ? "R" : "F");
			_m_writer->write_int(ani.first_frame);
			_m_writer->write_int(ani.last_frame);
			_m_writer->write_float(ani.fps);
			_m_writer->write_float(ani.speed);
			_m_writer->write_float(ani.collision_volume_scale);
		});
	}

	void MdsBinaryGenerator::write_animation_alias(const MdsAnimationAlias& alias) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ANIMATION_ALIAS, [&](Write* wr) {
			_m_writer->write_line(alias.name);
			_m_writer->write_uint(alias.layer);
			_m_writer->write_line(alias.next);
			_m_writer->write_float(alias.blend_in);
			_m_writer->write_float(alias.blend_out);
			_m_writer->write_line(format_flags(alias.flags));
			_m_writer->write_line(alias.alias);
			_m_writer->write_line(alias.direction == AnimationDirection::BACKWARD ? "R" : "F");
		});
	}

	void MdsBinaryGenerator::write_animation_blend(const MdsAnimationBlend& blend) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ANIMATION_BLEND, [&](Write* wr) {
			_m_writer->write_line(blend.name);
			_m_writer->write_line(blend.next);
			_m_writer->write_float(blend.blend_in);
			_m_writer->write_float(blend.blend_out);
		});
	}

	void MdsBinaryGenerator::write_animation_combine(const MdsAnimationCombine& comb) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ANIMATION_COMBINE, [&](Write* wr) {
			_m_writer->write_line(comb.name);
			_m_writer->write_uint(comb.layer);
			_m_writer->write_line(comb.next);
			_m_writer->write_float(comb.blend_in);
			_m_writer->write_float(comb.blend_out);
			_m_writer->write_line(format_flags(comb.flags));
			_m_writer->write_line(comb.model);
			_m_writer->write_int(comb.last_frame);
		});
	}

	void MdsBinaryGenerator::write_disabled_animation(const std::string& name) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::ANIMATION_DISABLE, [&](Write* wr) {
			_m_writer->write_line(name);
		});
	}

	void MdsBinaryGenerator::write_model_tag(const MdsModelTag& tag) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::MODEL_TAG, [&](Write* wr) {
			_m_writer->write_line("DEF_HIT_LIMB");
			_m_writer->write_line(tag.bone);
		});
	}

	void MdsBinaryGenerator::write_event_tag(const MdsEventTag& event) {
		proto::write_chunk(_m_writer, ModelScriptBinaryChunkType::EVENT_TAG, [&](Write* wr) {
			_m_writer->write_int(event.frame);
			auto it = std::find_if(std::begin(zenkit::event_types), std::end(zenkit::event_types), [&event](auto&& pair) { return pair.second == event.type; });
			_m_writer->write_line(it->first);

			switch (event.type) {
			case MdsEventType::ITEM_CREATE:
			case MdsEventType::ITEM_EXCHANGE:
				event.slot = c->read_line(true);
				event.item = c->read_line(true);
				break;
			case MdsEventType::ITEM_INSERT:
			case MdsEventType::MUNITION_PLACE:
				event.slot = c->read_line(true);
				break;
			case MdsEventType::SET_FIGHT_MODE: {
				if (auto mode = c->read_line(true); mode == "FIST") {
					event.fight_mode = MdsFightMode::FIST;
				} else if (mode == "1H" || mode == "1h") {
					event.fight_mode = MdsFightMode::SINGLE_HANDED;
				} else if (mode == "2H" || mode == "2h") {
					event.fight_mode = MdsFightMode::DUAL_HANDED;
				} else if (mode == "BOW") {
					event.fight_mode = MdsFightMode::BOW;
				} else if (mode == "CBOW") {
					event.fight_mode = MdsFightMode::CROSSBOW;
				} else if (mode == "MAG") {
					event.fight_mode = MdsFightMode::MAGIC;
				} else {
					event.fight_mode = MdsFightMode::NONE;
				}
				break;
			}
			case MdsEventType::MESH_SWAP:
				event.slot = c->read_line(true);
				event.slot2 = c->read_line(true);
				break;
			case MdsEventType::HIT_LIMB:
				event.slot = c->read_line(true); // TODO
				break;
			case MdsEventType::HIT_DIRECTION:
				event.slot = c->read_line(true); // TODO
				break;
			case MdsEventType::SOUND_DRAW:
			case MdsEventType::SOUND_UNDRAW:
			case MdsEventType::MUNITION_REMOVE:
			case MdsEventType::ITEM_DESTROY:
			case MdsEventType::TORCH_INVENTORY:
			case MdsEventType::ITEM_REMOVE:
				event.slot = c->read_line(true); // TODO
				break;
			case MdsEventType::DAMAGE_MULTIPLIER: // TODO: one float, in quotes?
			case MdsEventType::PARRY_FRAME:
			case MdsEventType::OPTIMAL_FRAME:
			case MdsEventType::HIT_END:
			case MdsEventType::COMBO_WINDOW: {
				auto frames = c->read_line(true);
				std::istringstream stream {frames};

				int32_t frame = 0;
				while (!stream.eof()) {
					stream >> frame;
					event.frames.push_back(frame);
				}
				break;
			}
			default:
				break;
			}
		});
	}

	void MdsBinaryGenerator::write_event_sfx(const MdsSoundEffect& sfx) {}
	void MdsBinaryGenerator::write_event_sfx_ground(const MdsSoundEffectGround& sfx) {}
	void MdsBinaryGenerator::write_event_pfx(const MdsParticleEffect& pfx) {}
	void MdsBinaryGenerator::write_event_pfx_stop(const MdsParticleEffectStop& pfx) {}
	void MdsBinaryGenerator::write_event_morph(const MdsMorphAnimation& morph) {}
	void MdsBinaryGenerator::write_event_tremor(const MdsCameraTremor& tremor) {}

	std::string MdsBinaryGenerator::format_flags(AnimationFlags flags) {
		std::string result;
		if (flags & AnimationFlags::MOVE) result += "M";
		if (flags & AnimationFlags::ROTATE) result += "R";
		if (flags & AnimationFlags::QUEUE) result += "E";
		if (flags & AnimationFlags::FLY) result += "F";
		if (flags & AnimationFlags::IDLE) result += "I";
		if (flags & AnimationFlags::INPLACE) result += "P";
		result += ".";
		return result;
	}
} // namespace zenkit
