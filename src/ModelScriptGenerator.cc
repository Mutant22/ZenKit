// Copyright Â© 2022-2023 GothicKit Contributors.
// SPDX-License-Identifier: MIT
#include "ModelScriptGenerator.hh"
#include "Internal.hh"

#include "zenkit/Date.hh"
#include "zenkit/Stream.hh"

#include <sstream>

namespace zenkit {
	// ===== MdsGenerator Implementation =====
	MdsGenerator::MdsGenerator(Write* w) : _m_writer(w) {}

	void MdsGenerator::generate_script(const ModelScript& script) {
		// Write Model block
		_m_writer->write_string("// Generated by ZenKit ModelScript DSL Generator\n");
		_m_writer->write_string("Model (\"");
		std::string model_name = script.skeleton.name;
		std::transform(model_name.begin(), model_name.end(), model_name.begin(), ::toupper);
		size_t pos = model_name.find(".ASC");
		if (pos != std::string::npos) {
			model_name.erase(model_name.begin() + pos, model_name.end());
		}
		_m_writer->write_string(model_name);
		_m_writer->write_string("\")\n{\n");

		// Write skeleton first (always present)
		write_skeleton(script.skeleton);

		// Iterate through lines to preserve source order
		for (const auto& line : script.lines) {
			switch (line.type) {
			case MdsElementType::SKELETON:
				// Already written at the top
				break;
			case MdsElementType::ANIMATION:
				write_animation(script.animations[line.index]);
				break;
			case MdsElementType::ANIMATION_ALIAS:
				write_animation_alias(script.aliases[line.index]);
				break;
			case MdsElementType::ANIMATION_BLEND:
				write_animation_blend(script.blends[line.index]);
				break;
			case MdsElementType::ANIMATION_COMBINE:
				write_animation_combine(script.combinations[line.index]);
				break;
			case MdsElementType::ANIMATION_DISABLED:
				write_disabled_animation(script.disabled_animations[line.index]);
				break;
			case MdsElementType::MODEL_TAG:
				write_model_tag(script.model_tags[line.index]);
				break;
			case MdsElementType::MESH:
				write_mesh(script.meshes[line.index]);
				break;
			case MdsElementType::ANI_ENUM:
				_m_writer->write_string("\taniEnum\n");
				_m_writer->write_string("\t{\n");
				break;
			case MdsElementType::ANI_ENUM_END:
				_m_writer->write_string("\t}\n");
				break;
			}
		}

		// Close Model block
		_m_writer->write_string("}\n");
	}

	void MdsGenerator::write_skeleton(const MdsSkeleton& skeleton) {
		std::ostringstream ss;
		ss << "\tmeshAndTree (\"" << skeleton.name;
		std::string skeleton_name = skeleton.name;

		std::transform(skeleton_name.begin(), skeleton_name.end(), skeleton_name.begin(), ::toupper);
		size_t pos = skeleton_name.find(".ASC");
		if (pos == std::string::npos) {
			ss << ".ASC\"";
		} else {
			ss << "\"";
		}

		if (skeleton.disable_mesh) {
			ss << " DONT_USE_MESH";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_mesh(const std::string& mesh) {
		_m_writer->write_string("\tregisterMesh (\"" + mesh + "\")\n");
	}

	void MdsGenerator::write_animation(const MdsAnimation& ani) {
		std::ostringstream ss;
		ss << "\t\tani (\"" << ani.name << "\" "
		   << ani.layer << " \""
		   << ani.next << "\" "
		   << ani.blend_in << " "
		   << ani.blend_out << " "
		   << format_flags(ani.flags) << " \""
		   << ani.model << "\" "
		   << format_direction(ani.direction) << " "
		   << ani.first_frame << " "
		   << ani.last_frame;

		if (ani.fps != 25.0f) {
			ss << " FPS:" << ani.fps;
		}
		if (ani.speed != 0.0f) {
			ss << " SPD:" << ani.speed;
		}
		if (ani.collision_volume_scale != 1.0f) {
			ss << " CVS:" << ani.collision_volume_scale;
		}

		ss << ")\n";
		_m_writer->write_string(ss.str());

		// Check if animation has any events
		if (ani.event_lines.empty()) {
			return;
		}

		// Write animation events
		_m_writer->write_string("\t\t{\n");

		for (const auto& line : ani.event_lines) {
			switch (line.type) {
			case MdsAniEventType::EVENT_TAG:
				write_event_tag(ani.events[line.index]);
				break;
			case MdsAniEventType::SOUND_EFFECT:
				write_event_sfx(ani.sfx[line.index]);
				break;
			case MdsAniEventType::SOUND_EFFECT_GROUND:
				write_event_sfx_ground(ani.sfx_ground[line.index]);
				break;
			case MdsAniEventType::PARTICLE_EFFECT:
				write_event_pfx(ani.pfx[line.index]);
				break;
			case MdsAniEventType::PARTICLE_EFFECT_STOP:
				write_event_pfx_stop(ani.pfx_stop[line.index]);
				break;
			case MdsAniEventType::MORPH_ANIMATION:
				write_event_morph(ani.morph[line.index]);
				break;
			case MdsAniEventType::CAMERA_TREMOR:
				write_event_tremor(ani.tremors[line.index]);
				break;
			}
		}

		_m_writer->write_string("\t\t}\n");
	}

	void MdsGenerator::write_animation_alias(const MdsAnimationAlias& alias) {
		std::ostringstream ss;
		ss << "\t\taniAlias (\"" << alias.name << "\" "
		   << alias.layer << " \""
		   << alias.next << "\" "
		   << alias.blend_in << " "
		   << alias.blend_out << " "
		   << format_flags(alias.flags) << " \""
		   << alias.alias << "\" "
		   << format_direction(alias.direction)
		   << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_animation_blend(const MdsAnimationBlend& blend) {
		std::ostringstream ss;
		ss << "\t\taniBlend (\"" << blend.name << "\" \""
		   << blend.next << "\"";
		if (blend.blend_in != 0.0f || blend.blend_out != 0.0f) {
			ss << " " << blend.blend_in << " " << blend.blend_out;
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_animation_combine(const MdsAnimationCombine& comb) {
		std::ostringstream ss;
		ss << "\t\taniComb (\"" << comb.name << "\" "
		   << comb.layer << " \""
		   << comb.next << "\" "
		   << comb.blend_in << " "
		   << comb.blend_out << " "
		   << format_flags(comb.flags) << " \""
		   << comb.model << "\" "
		   << comb.last_frame
		   << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_disabled_animation(const std::string& ani) {
		_m_writer->write_string("\t\taniDisable (\"" + ani + "\")\n");
	}

	void MdsGenerator::write_model_tag(const MdsModelTag& tag) {
		_m_writer->write_string("\t\tmodelTag (\"DEF_HIT_LIMB\" \"" + tag.bone + "\")\n");
	}

	void MdsGenerator::write_event_tag(const MdsEventTag& event) {
		std::ostringstream ss;
		ss << "\t\t\t*eventTag (" << event.frame << " \"";

		// Convert event type to string
		switch (event.type) {
		case MdsEventType::ITEM_CREATE:
			ss << "DEF_CREATE_ITEM\" \"" << event.slot << "\" \"" << event.item << "\"";
			break;
		case MdsEventType::ITEM_INSERT:
			ss << "DEF_INSERT_ITEM\" \"" << event.slot << "\"";
			break;
		case MdsEventType::ITEM_REMOVE:
			ss << "DEF_REMOVE_ITEM\"";
			break;
		case MdsEventType::ITEM_DESTROY:
			ss << "DEF_DESTROY_ITEM\"";
			break;
		case MdsEventType::ITEM_PLACE:
			ss << "DEF_PLACE_ITEM\"";
			break;
		case MdsEventType::ITEM_EXCHANGE:
			ss << "DEF_EXCHANGE_ITEM\" \"" << event.slot << "\" \"" << event.item << "\"";
			break;
		case MdsEventType::SET_FIGHT_MODE:
			ss << "DEF_FIGHTMODE\" \"";
			switch (event.fight_mode) {
			case MdsFightMode::FIST:
				ss << "FIST";
				break;
			case MdsFightMode::SINGLE_HANDED:
				ss << "1H";
				break;
			case MdsFightMode::DUAL_HANDED:
				ss << "2H";
				break;
			case MdsFightMode::BOW:
				ss << "BOW";
				break;
			case MdsFightMode::CROSSBOW:
				ss << "CBOW";
				break;
			case MdsFightMode::MAGIC:
				ss << "MAG";
				break;
			default:
				ss << "NONE";
				break;
			}
			ss << "\"";
			break;
		case MdsEventType::MUNITION_PLACE:
			ss << "DEF_PLACE_MUNITION\" \"" << event.slot << "\"";
			break;
		case MdsEventType::MUNITION_REMOVE:
			ss << "DEF_REMOVE_MUNITION\"";
			break;
		case MdsEventType::SOUND_DRAW:
			ss << "DEF_DRAWSOUND\"";
			break;
		case MdsEventType::SOUND_UNDRAW:
			ss << "DEF_UNDRAWSOUND\"";
			break;
		case MdsEventType::MESH_SWAP:
			ss << "DEF_SWAPMESH\" \"" << event.slot << "\" \"" << event.slot2 << "\"";
			break;
		case MdsEventType::TORCH_DRAW:
			ss << "DEF_DRAWTORCH\"";
			break;
		case MdsEventType::TORCH_INVENTORY:
			ss << "DEF_INV_TORCH\"";
			break;
		case MdsEventType::TORCH_DROP:
			ss << "DEF_DROP_TORCH\"";
			break;
		case MdsEventType::HIT_LIMB:
			ss << "DEF_HIT_LIMB\"";
			break;
		case MdsEventType::HIT_DIRECTION:
			ss << "DEF_HIT_DIR\"";
			break;
		case MdsEventType::DAMAGE_MULTIPLIER:
			ss << "DEF_DAM_MULTIPLY\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::PARRY_FRAME:
			ss << "DEF_PAR_FRAME\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::OPTIMAL_FRAME:
			ss << "DEF_OPT_FRAME\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::HIT_END:
			ss << "DEF_HIT_END\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		case MdsEventType::COMBO_WINDOW:
			ss << "DEF_WINDOW\" \"";
			for (size_t i = 0; i < event.frames.size(); ++i) {
				if (i > 0) ss << " ";
				ss << event.frames[i];
			}
			ss << "\"";
			break;
		default:
			ss << "UNKNOWN\"";
			break;
		}

		if (event.attached) {
			ss << " ATTACH";
		}

		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_sfx(const MdsSoundEffect& sfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventSFX (" << sfx.frame << " \"" << sfx.name << "\"";
		if (sfx.range != 1000.0f) {
			ss << " R:" << sfx.range;
		}
		if (sfx.empty_slot) {
			ss << " EMPTY_SLOT";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_sfx_ground(const MdsSoundEffectGround& sfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventSFXGrnd (" << sfx.frame << " \"" << sfx.name << "\")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_pfx(const MdsParticleEffect& pfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventPFX (" << pfx.frame;
		if (pfx.index != 0) {
			ss << " " << pfx.index;
		}
		ss << " \"" << pfx.name << "\" \"" << pfx.position << "\"";
		if (pfx.attached) {
			ss << " ATTACH";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_pfx_stop(const MdsParticleEffectStop& pfx) {
		std::ostringstream ss;
		ss << "\t\t\t*eventPFXStop (" << pfx.frame << " " << pfx.index << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_morph(const MdsMorphAnimation& morph) {
		std::ostringstream ss;
		ss << "\t\t\t*eventMMStartAni (" << morph.frame << " \"" << morph.animation << "\"";
		if (!morph.node.empty()) {
			ss << " \"" << morph.node << "\"";
		}
		ss << ")\n";
		_m_writer->write_string(ss.str());
	}

	void MdsGenerator::write_event_tremor(const MdsCameraTremor& tremor) {
		std::ostringstream ss;
		ss << "\t\t\t*eventCamTremor (" << tremor.frame << " "
		   << tremor.field1 << " "
		   << tremor.field2 << " "
		   << tremor.field3 << " "
		   << tremor.field4 << ")\n";
		_m_writer->write_string(ss.str());
	}

	std::string MdsGenerator::format_flags(AnimationFlags flags) {
		std::string result;
		if (flags & AnimationFlags::MOVE) result += "M";
		if (flags & AnimationFlags::ROTATE) result += "R";
		if (flags & AnimationFlags::QUEUE) result += "E";
		if (flags & AnimationFlags::FLY) result += "F";
		if (flags & AnimationFlags::IDLE) result += "I";
		if (flags & AnimationFlags::INPLACE) result += "P";
		result += ".";
		return result;
	}

	std::string MdsGenerator::format_direction(AnimationDirection dir) {
		return dir == AnimationDirection::FORWARD ? "F" : "R";
	}

	// ===== MdsBinaryGenerator Implementation =====
	MdsBinaryGenerator::MdsBinaryGenerator(Write* w) : _m_writer(w) {}

	void MdsBinaryGenerator::generate_script(const ModelScript& script) {
		// TODO: Implement binary generation
		// For now, this is a placeholder. Binary generation would need to:
		// 1. Write proper chunk headers
		// 2. Handle all the binary format specifics
		// The binary format uses proto::write_chunk but needs proper enum types
		ZKLOGW("ModelScript", "Binary generation not yet fully implemented");
	}

	void MdsBinaryGenerator::write_skeleton(const MdsSkeleton& skeleton) {}
	void MdsBinaryGenerator::write_mesh(const std::string& mesh) {}
	void MdsBinaryGenerator::write_animation(const MdsAnimation& ani) {}
	void MdsBinaryGenerator::write_animation_alias(const MdsAnimationAlias& alias) {}
	void MdsBinaryGenerator::write_animation_blend(const MdsAnimationBlend& blend) {}
	void MdsBinaryGenerator::write_animation_combine(const MdsAnimationCombine& comb) {}
	void MdsBinaryGenerator::write_disabled_animation(const std::string& name) {}
	void MdsBinaryGenerator::write_model_tag(const MdsModelTag& tag) {}
	void MdsBinaryGenerator::write_event_tag(const MdsEventTag& event) {}
	void MdsBinaryGenerator::write_event_sfx(const MdsSoundEffect& sfx) {}
	void MdsBinaryGenerator::write_event_sfx_ground(const MdsSoundEffectGround& sfx) {}
	void MdsBinaryGenerator::write_event_pfx(const MdsParticleEffect& pfx) {}
	void MdsBinaryGenerator::write_event_pfx_stop(const MdsParticleEffectStop& pfx) {}
	void MdsBinaryGenerator::write_event_morph(const MdsMorphAnimation& morph) {}
	void MdsBinaryGenerator::write_event_tremor(const MdsCameraTremor& tremor) {}
} // namespace zenkit
